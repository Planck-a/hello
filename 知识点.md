1、进程间通信
---
进程间通信分为两大类，第一类是在一台主机上的不同进程：管道、命名管道、消息队列、共享内存
第二类是在两台主机上：socket
管道是在父子进程中通信的，是半双工的，如果需要全双工，那么就需要建立两个管道
命名管道是在不相关的进程之间，通过管道号进行通信，也是半双工
消息队列：双方协商好传递消息的数据类型，通过key进行连接。key值属于要通信的进程双方互相沟通好的，作为在内核里找到它们专属的消息队列的桥梁。
共享内存：唯一不在内核缓存区进行的通信，所以速度也是最快的，开发中最常用的。
```cpp
消息队列   最大长度64k，最大16条
int msgget(key_t key，int msgflag);
//创建消息队列或者获取消息队列,key是队列名，msgflag是9位权限位 rwx rwx rwx

int main1()
{
    int msgqid=msgget(0x1234,0666);//创建消息队列或者获取消息队列
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；//没有指定创建且没有消息队列返回
    } 
}
int main2()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT);//指定创建
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int main3()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT|IPC_EXCL);//开发中优先用这个
    //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int msgctl();
int main4()
{
    int msgqid=msgget(0x1234,0666);
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
    struct msqid_ds buf;
    int ret = magctl(msgid,IPC_STAT,&buf);//传出到buf中，获取对消息队列的控制
}
int msgsnd();
int msgrcv();
```
```cpp
管道======》都是linux内核的缓冲区
管道是半双工的，如果双方需要通信，那么就建立两个管道
管道的读写可以设置成阻塞/非阻塞
int main()
{
    int pipefd[2];
    int ret=pipe(pipefd);//创建管道，fd1写，fd0读
    int pid=fork();
    if(pid == 0)
    {
        close(pipefd[0]);
        write(pipefd[1],"hdsjdskjhdsjk",6);//rw
        close(pipefd[1]);
    }
    close(pipefd[1]);
    char buf[1024]={0};
    int n=read(pipefd[0],buf,sizeof(buf));
    close(pipefd[0]);
}

设置非阻塞：
int flag= fcntl(int fd, F_GETFL);//第二个命令cmd是指get set
flag= flag| O_NONBLOCK;
int ret=fcntl( fd, F_SETFL,flag);
```
```cpp
共享内存   ====》不陷入内核，读写涉及加锁，和信号量放在一起
将内核中的缓冲区映射到用户空间，可以选择修改后是否重新同步给内核缓冲区
ipcs-------> nattach  表示有多少个进程连接这个共享内存了


int main3()
{
   int shmid= shmget(0x2234,sizeof(Teacher),0666|IPC_CREAT|IPC_EXCL);
   //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("共享内存不存在")；
    }
    Teacher *p=NULL;
    P=shmat(shmid,NULL,0);//映射到用户空间，p就是共享内存的首地址
}
```

2、虚拟内存和物理内存
---
虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。

假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0~0xFFFFFFFF（4G）的地址空间，但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？
答：计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（page frame），这个页和页帧的大小是一样大的，但是虚拟内存页的个数 > 物理内存页帧的个数。在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射。操作系统有个页面失效（page fault）功能。当缺页中断时，操作系统通过页面置换算法 找到一个最少使用的页帧（物理内存中），让他失效，并把它写入磁盘（临时保存一下），随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。这就是处理虚拟内存地址到物理内存的步骤。

虚拟内存地址由页号和偏移量组成，那么先把页号映射到页帧，然后在页帧+偏移量组成物理上真正存在的地址。

补充：
`top中虚拟内存VIRT和RES常驻内存的关系？`
VIRT：
进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等；如果new了100M，但是我现在只往里面写1M，这时VIRT增加100M，RES增加1M
RES:
malloc了100M的内存，但是只给其中里面写1M，则RES增加1M
```cpp
#include <iostream>
 
int main()
{
    char * p = new char [1024*1024*512];
    getchar();
    return 0;
 }
 
top结果如下：
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
401 huyiyang  17   0  523m  916  792 S  0.0  0.0   0:00.00 ./main
```
```cpp
#include <iostream>
 
int main()
{
    char * p = new char [1024*1024*512];
    memset(p, 0, 1024*1024*512);
    getchar();
    return 0;
}
top结果如下：
PID   USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  
32604 huyiyang  17   0  523m  512m  792 S  0.0 26.2   0:00.33 ./main
```

