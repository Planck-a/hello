1、进程间通信
---
进程间通信分为两大类，第一类是在一台主机上的不同进程：管道、命名管道、消息队列、共享内存
第二类是在两台主机上：socket
管道是在父子进程中通信的，是半双工的，如果需要全双工，那么就需要建立两个管道
命名管道是在不相关的进程之间，通过管道号进行通信，也是半双工
消息队列：双方协商好传递消息的数据类型，通过key进行连接。key值属于要通信的进程双方互相沟通好的，作为在内核里找到它们专属的消息队列的桥梁。
共享内存：唯一不在内核缓存区进行的通信，所以速度也是最快的，开发中最常用的。
```cpp
消息队列   最大长度64k，最大16条
int msgget(key_t key，int msgflag);
//创建消息队列或者获取消息队列,key是队列名，msgflag是9位权限位 rwx rwx rwx

int main1()
{
    int msgqid=msgget(0x1234,0666);//创建消息队列或者获取消息队列
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；//没有指定创建且没有消息队列返回
    } 
}
int main2()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT);//指定创建
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int main3()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT|IPC_EXCL);//开发中优先用这个
    //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int msgctl();
int main4()
{
    int msgqid=msgget(0x1234,0666);
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
    struct msqid_ds buf;
    int ret = magctl(msgid,IPC_STAT,&buf);//传出到buf中，获取对消息队列的控制
}
int msgsnd();
int msgrcv();
```
```cpp
管道======》都是linux内核的缓冲区
管道是半双工的，如果双方需要通信，那么就建立两个管道
管道的读写可以设置成阻塞/非阻塞
int main()
{
    int pipefd[2];
    int ret=pipe(pipefd);//创建管道，fd1写，fd0读
    int pid=fork();
    if(pid == 0)
    {
        close(pipefd[0]);
        write(pipefd[1],"hdsjdskjhdsjk",6);//rw
        close(pipefd[1]);
    }
    close(pipefd[1]);
    char buf[1024]={0};
    int n=read(pipefd[0],buf,sizeof(buf));
    close(pipefd[0]);
}

设置非阻塞：
int flag= fcntl(int fd, F_GETFL);//第二个命令cmd是指get set
flag= flag| O_NONBLOCK;
int ret=fcntl( fd, F_SETFL,flag);
```
```cpp
共享内存   ====》不陷入内核，读写涉及加锁，和信号量放在一起
将内核中的缓冲区映射到用户空间，可以选择修改后是否重新同步给内核缓冲区
ipcs-------> nattach  表示有多少个进程连接这个共享内存了


int main3()
{
   int shmid= shmget(0x2234,sizeof(Teacher),0666|IPC_CREAT|IPC_EXCL);
   //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("共享内存不存在")；
    }
    Teacher *p=NULL;
    P=shmat(shmid,NULL,0);//映射到用户空间，p就是共享内存的首地址
}
```

2、虚拟内存和物理内存
---
虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。
假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0~0xFFFFFFFF（4G）的地址空间，
但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？
