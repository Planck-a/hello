1、多进程下的文件描述符
---
父进程打开文件，父子进程同时往文件中写
```
int fd=open("1.txt",0_RDWR);
int pid=fork();
if(pid >0)
{
  //parent
  write(fd,"parent",6);
  close(fd);
}
if(pid == 0)
{
  write(fd,"child",6);
  close(fd);
  exit(0);
}
```
父子进程谁先写不确定

父子进程拥有各自的内存空间，每个内存空间有文件描述符表，fd0是标注输入，fd1是标准输出，fd2是标准库，之后空白的文件描述符用来装载打开的文件描述符，fd3可能就是我们打开的文件描述符。
fd3指向了文件状态标识表+文件表，所以父子进程通过各自的fd指向同一个文件表+文件状态标识表；

由于父子进程中打开了该文件，所以相当于文件状态的引用计数是2，关闭时父子进程都要close；

2 进程终止的5种方式
--
正常退出：(1)main函数返回 (2)exit  (3)_exit  

异常退出：(4)调用abort    (5)ctrl+c 

(1)exit是c库函数，相当于封装了_exit，先做了清除缓冲区操作，再调用_exit
```
void main()
{
  printf("abcd");
  exit(0);
}
```
会先打印出abcd，再退出；

(2)_exit是系统调用，直接陷入Linux内核，终止进程运行
- 情况一：
```
void main()
{
  printf("abcd");
  _exit(0);
}
```
不会打印abcd，直接退出了
- 情况二：
```
void main()
{
  printf("abcd\n");
  _exit(0);
}
```
\n会刷新缓冲区，所以又能先打印出abcd，再退出；
- 情况三：
```
void main()
{
  printf("abcd");
  fflush(stdout);
  _exit(0);
}
```
手动刷新缓冲区，所以又能先打印出abcd，再退出；
- 情况四：
注册回调函数，exit退出后自动调用回调函数；可以注册多个回调函数，先注册的后调用;exit之后会调用这个函数。
```
void bye1()
{
  printf("bye1");
}
void bye2()
{
  printf("bye2");
}

void main()
{
  atexit(bye1);
  atexit(bye2);
  printf("abcd");
  fflush(stdout);
  _exit(0);
}
```
3 进程睡眠
---
进程睡眠分为可中断睡眠和不可中断睡眠两种，ctrl+c能杀死的就是可中断睡眠

举例：
```
void main()
{
  sleep(100);//可中断睡眠，ctrl+c可以杀死
}
```
